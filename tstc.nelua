require 'vector'
require 'string'
require 'stringbuilder'
require 'C.stdio'
require 'io'

local Token:type=@record{
    type:string,
    value:string,
}
local ASTNode=@record{
    type:string,
    u:union{
        Program:record{
            body:vector(*ASTNode),
        },
        NumberLiteral:record{
            value:string,
        },
        StringLiteral:record{
            value:string,
        },
        CallExpression:record{
            name:string,
            params:vector(*ASTNode),
        },
        ExpressionStatement:record{
            expression:*ASTNode,
        },
        Call:record{
            callee:record{
                type:string,
                name:string,
            },
            arguments:vector(*ASTNode),
        }
    },
    _context:*vector(*ASTNode),
}

local function print_AST_R(node: ASTNode, nest: integer)
    for i=0,<nest do
        io.stdout:write("\t")
    end
    io.stdout:writef("%s", node.type)
    if node.type=='Program' then
        print(' body=\\')
        for i=0,<#node.u.Program.body do
            print_AST_R(node.u.Program.body[i], nest + 1)
        end
    end
    if node.type=='NumberLiteral' or node.type=='StringLiteral' then
        io.stdout:writef(" value=%s\n", node.u.NumberLiteral.value)
    end
    if node.type=='CallExpression' then
        io.stdout:writef(" name=%s", node.u.CallExpression.name)
        io.stdout:write(" params=\\\n")
        for i=0,<#node.u.CallExpression.params do
            print_AST_R(node.u.CallExpression.params[i], nest + 1)
        end
    end
    if node.type=='ExpressionStatement' then
        print_AST_R(node.u.ExpressionStatement.expression, nest + 1)
    end
    if node.type=='Call' then
        io.stdout:writef(" callee type=%s",node.u.Call.callee.type)
        io.stdout:writef(" name=%s",node.u.Call.callee.name)
        io.stdout:write(" arguments=\\\n")
        for i=0,<#node.u.Call.arguments do
            print_AST_R(node.u.Call.arguments[i], nest + 1)
        end
    end
end

local function print_AST(ast: ASTNode) print_AST_R(ast, 0) end

local function is_space(c:byte) return c==' '_byte or c<='\n'_byte end
local function is_number(c:byte) return c>='0'_byte and c<='9'_byte end
local function is_letter(c:byte) return c>='a'_byte and c<='z'_byte end

local function tokenizer(input: string): vector(Token)
    local current=0
    local tokens:vector(Token)
    while current<#input do
        local c=input.data[current]
        if c=='('_byte then
            tokens:push(Token{'paren','('})
            current=current+1
            continue
        end
        if c==')'_byte then
            tokens:push(Token{'paren',')'})
            current=current+1
            continue
        end
        if is_space(c) then
            current=current+1
            continue
        end
        if is_number(c) then
            local sb:stringbuilder
            while is_number(c) do
                sb:write_byte(c)
                current=current+1
                c=input.data[current]
            end
            local value:stringview=sb
            tokens:push(Token{'number',value})
            continue
        end
        if is_letter(c) then
            local sb:stringbuilder
            while is_letter(c) do
                sb:write_byte(c)
                current=current+1
                c=input.data[current]
            end
            local value:stringview=sb
            tokens:push(Token{'name',value})
            continue
        end
        error(string.format("I don't know what this character is: `%c`", c))
    end
    return tokens
end

local function parser(tokens: vector(Token)): ASTNode
    local function walk(current: integer, tokens:vector(Token))
        local token = tokens[current]
        if token.type == 'number' then
            current=current+1
            return current,ASTNode{
                type='NumberLiteral',
                u={
                    NumberLiteral={
                        value=token.value,
                    },
                },
            }
        end
        if token.type == 'string' then
            current=current+1
            return current,ASTNode{
                type='StringLiteral',
                u={
                    StringLiteral={
                        value=token.value,
                    },
                },
            }
        end
        if token.type == 'paren' and token.value == '(' then
            current=current+1
            token=tokens[current]
            local node = ASTNode{
                type='CallExpression',
                u={
                    CallExpression={
                        name=token.value,
                    },
                },
            }
            current=current+1
            token=tokens[current]
            while token.type ~= 'paren' or (token.type == 'paren' and token.value ~= ')') do
                local child:ASTNode
                current,child=walk(current,tokens)
                node.u.CallExpression.params:push(gc_allocator:new(child))
                token=tokens[current]
            end
            current=current+1
            return current,node
        end
        error(string.format("Type error: `%s`", token.type))
    end
    local current=0
    local ast = ASTNode{
        'Program',
    }
    while current<#tokens do
        local node:ASTNode
        current,node=walk(current,tokens)
        ast.u.Program.body:push(gc_allocator:new(node))
    end
    return ast
end

local function traverseNode(node: ASTNode, parent: pointer(ASTNode))
    if node.type=='NumberLiteral' then
        if parent._context~=nilptr then
            local ctx:*vector(*ASTNode)=&$parent._context
            ctx:push(gc_allocator:new(ASTNode{
                type='NumberLiteral',
                u={
                    NumberLiteral={
                        value=node.u.NumberLiteral.value,
                    },
                },
            }))
        end
    end
    if node.type=='StringLiteral' then
        local ctx:*vector(*ASTNode)=&$parent._context
        ctx:push(gc_allocator:new(ASTNode{
            type='StringLiteral',
            u={
                StringLiteral={
                    value=node.u.StringLiteral.value,
                },
            },
        }))
        print('Done')
    end
    if node.type=='CallExpression' then
        local expression=gc_allocator:new(ASTNode{
            type='Call',
            u={
                Call={
                    callee={
                        type='Identifier',
                        name=node.u.CallExpression.name,
                    },
                },
            },
        })
        node._context = &expression.u.Call.arguments
        if parent.type ~= 'CallExpression' then
            local expression2=gc_allocator:new(ASTNode{
                type='ExpressionStatement',
                u={
                    ExpressionStatement={
                        expression=expression,
                    },
                },
            })
            if parent._context~=nilptr then
                local ctx:*vector(*ASTNode)=&$parent._context
                ctx:push(expression2)
            end
        else
            if parent._context~=nilptr then
                local ctx:*vector(*ASTNode)=&$parent._context
                ctx:push(expression)
            end
        end
    end
    if node.type == 'Program' then
        --traverseArray(node.body, node)
        for i=0,<#node.u.Program.body do traverseNode(node.u.Program.body[i], node) end
    elseif node.type == 'CallExpression' then
        --traverseArray(node.params, node)
        for i=0,<#node.u.CallExpression.params do traverseNode(node.u.CallExpression.params[i], node) end
    elseif node.type == 'NumberLiteral' or node.type == 'StringLiteral' then
        -- nothing special
    else
        error(string.format("Type error: `%s`", node.type))
    end
end

local function traverser(ast: ASTNode)
    traverseNode(ast, nilptr)
end

local function transformer(ast: ASTNode):ASTNode
    local newAst = ASTNode{
        type='Program',
    }
    ast._context = &newAst.u.Program.body
    traverser(ast)
    return newAst
end

local function codeGenerator(node: ASTNode):string
    local sb:stringbuilder
    if node.type=='Program' then
        sb:write_string("int main() {\n")
        for i=0,<#node.u.Program.body do
            sb:write_string(codeGenerator(node.u.Program.body[i]))
        end
        sb:write_string("}\n")
    elseif node.type=='NumberLiteral' then
        sb:write_string(node.u.NumberLiteral.value)
    elseif node.type=='ExpressionStatement' then
        sb:write_string("\t")
        sb:write_string(codeGenerator(node.u.ExpressionStatement.expression))
        sb:write_string(";\n")
    elseif node.type=='Call' then
        sb:write_string(node.u.Call.callee.name)
        sb:write_string("(")
        for i=0,<#node.u.Call.arguments do
            if i>0 then
                sb:write_string(", ")
            end
            sb:write_string(codeGenerator(node.u.Call.arguments[i]))
        end
        sb:write_string(")")
    else
        error(string.format("Code gen Type error: `%s`", node.type))
    end
    --sb:write_byte(65)
    local output:stringview=sb
    return output
    --return stringview(sb)
end

local function print_tokens(tokens:vector(Token))
    --print("Found ",#tokens," tokens")
    for t=0,<#tokens do
        print(tokens[t].type,tokens[t].value)
        --io.stdout:writef("%s",tokens[t].type)
        --io.stdout:writef("%s",tokens[t].value)
    end
end

local function compiler(input: string):string
    print('input=\\\n',input)
    --io.stdout:writef("input=\\\n%s",input)
    local tokens=tokenizer(input)
    --print_tokens(tokens)
    local ast=parser(tokens)
    --print_AST(ast)
    local newAst=transformer(ast)
    --print_AST(newAst)
    local output=codeGenerator(newAst)
    return output
end

local source=[[
    (add 2 2)
    (subtract 4 2)
    (add 2 (subtract 4 2))
]]
local output=compiler(source)
io.stdout:writef("output=\\\n%s",output)
